\chapter{Статический анализ гонок}
\label{cha:static-methods}

При статическом анализе для поиска гонок используются следующие подходы:
\begin{itemize}
\item аннотирование кода,
\item анализ потока выполнения программы.
\end{itemize}

\textbf{Аннотирование кода} выполняется за счёт добавления специальных конструкций, содержащих информацию об объектах взаимоисключения, обеспечивающих защиту доступа к переменным, вызовам функций в исходный код программы. В листинге~\ref{lst:annotation_example1} и листинге~\ref{lst:annotation_example2} представлены примеры разных способов аннотирования кода для контроля захвата блокировок при доступе к переменным или функциям. Недостатком данного метода является необходимость добавления большого числа аннотаций, что влечет за собой увеличение объема кода, а, следовательно, и ухудшение читаемости кода, а также возможность допущения ошибок при самом аннотировании. Достоинством данного метода является гарантированная проверка захвата необходимых объектов взаимоисключения, указанных в аннотации, за исключением особых случаев, примеры которых показаны в листинге~\ref{lst:annotation_example2}.

\lstinputlisting[language=Java,caption=Пример №1. Аннотирование кода (\Code{annotation1.java}),label=lst:annotation_example1]{inc/src/annotation1.java}

\lstinputlisting[language=C,caption=Пример №2. Аннотирование кода (\Code{annotation2.cpp}),label=lst:annotation_example2]{inc/src/annotation2.cpp}

\lstinputlisting[language=C,caption=Пример №3. Аннотирование кода (\Code{annotation3.cpp}),label=lst:annotation_example3]{inc/src/annotation3.cpp}

\textbf{Анализ потока выполнения программы} бла-бла-бла.

Основная идея статического поиска гонок заключается в том, чтобы удостовериться, что для каждой общей области памяти существует по крайней мере одна блокировка, которая берётся во всех потоках при доступе к этой области. Тогда в случае, когда один поток удерживает блокировку, обеспечивается взаимно исключающий доступ к данным, что позволяет избежать гонок. Для того, чтобы определить, существует ли общая блокировка, можно вычислить набор блокировок, которые удерживаются в каждой точке программы, при этом должны отслеживаться только те блокировки, которые захватываются на всех путях, проходящих через эту точку. Вычислив множества всегда удерживаемых блокировок для каждой точки программы, достаточно просто проверить пересечение этих множеств в тех точках, где происходит доступ к исследуемой области памяти. Если пересечение не пусто, то можно сделать вывод о том, что гонки при доступе к данной области памяти отсутствуют, в противном случае существует потенциальная возможность возникновения гонок.

Чтобы применить эти базовые идеи к анализу реальных программ на C, нужно решить следующие задачи. Прежде всего, нужно определить области памяти, к которым производится доступ, что является нетривиальной задачей. Даже без динамического выделения памяти нужно провести анализ указателей. Например, если два различных указателя, p и q, указывают на одну и ту же область памяти, то, например, доступ к полям структуры p->data и q->data может привести к гонкам. Операции захвата и освобождения блокировок на языке C лексически не ограничены, поэтому информацию об указателях необходимо отслеживать контексто-чувствительно. Рассмотрим пример, представленный в листинге~\ref{lst:example1} 

\lstinputlisting[language=C,caption=Пример(\Code{example1.c}),label=lst:example1]{inc/src/example1.c}

Выполнение функции munge зависит от контекста, в котором происходит её вызов. В функции поседовательно выполняется захват блокировки, увеличение значения разделяемой переменной и освобожение блокировки. Переменная и блокировка передаются в фукнцию через указатели. Результат выполнения функции зависит от контекста, в котором она вызывается. К сожалению, получение контекстно-чувствительной информации об указателях является вычислительно дорогостоящим. Анализ каждого набора значений параметров вызываемой функции на основе полного перебора приводит к комбинаторному взрыву.

Существует три различных метода статического анализа, позволяющие решить эти проблемы:
\begin{itemize}
\item Locksmith,
\item CoBE,
\item RELAY.
\end{itemize}

Следует тометим, что контекстная-зависимость является не единственной проблемой, возникающей при статическом поиске гонок в программах на языке C. Во-первых, мьютексы являются не единственным способом обеспечения монопольного доступа к данным, cуществуют иные операции блокировки, например, семафоры. Во-вторых, возникают проблемы при анализе указателей, связанные с динамическим выделением памяти...

бла-бла-бла

Рассмотрим далее каждый из указанных методов подробнее.

\section{Locksmith}
Locksmith призводит аннотирование программы типами и эффектами. Основной идее является составление ограничений корреляции между доступами и блокировками. Для каждого доступа к области памяти $p$ c множеством блокировок $L$ составляется ограничение корреляции $p \triangleright L$. Для обозначения непрямого доступа через указатели и передаваемые параметры используется другая форма ограничений. Пусть $C$ - множество ограничений, тогда $C \vdash p \triangleright L$ показывает, что ограничение $p \triangleright L$ может быть получено из ограничений из $C$. Множество $S(C, p) = \{L | C \vdash p \triangleright L\}$ обозначает множество всех множест блокировок, которые захватываются при доступе к $p$. Область памяти $p$ считается защищенной мьютексом при условии, что пересечение всех множеств блокировок являтся непустым: $\cap S(C, p) \neq \emptyset$. В таком случае говорят, что данные, к которым производится доступ, постоянно коррелируют с множеством блокировок.

В основе данного метода лежит контекстно-чувствительное распространение информации об указателях. Множество обязательно захватываемых блокировок вычисляетс контексто-чувствительно, т.е. с учетом потока выполнения программы. Информация об указателях собирается контексто-нечувствительно (анализирубтся все присваивания в теле функции независимо от порядка, в котором эти присваивания могут быть выполнены). 

Потоко-чувствительное получение множест блокировок выполняется на основе анализа потока выполнения программы через граф потока управления. В этом методе для этого используются переменные состояния. Они позволяют использовать ограничения реализации (англ. instantiation constraints) для контекстно-чувствительного анализа множеств блокировок, и добавляют дополнительную ясность при вызове функций.

Потоко-нечувствительный анализ указателей в функции выполяется за счет порождения подтипов (англ. sub-typing). Идея состоит в том, что каждая область памяти имеет тип, который ассоциируется меткой области памяти $p$. Каждый раз как выполняется операция чтения или записи в переменную типа $ref^{p}(\tau)$, порождается ограничение $p \triangleright L$, где $L$ - текущее множество блокировок.

\section{CoBE}
Основной принцип заключается в том, что сначала производится определение разделяемых переменных и областей, к которым через эти переменные производится доступ. Если общая разделяемая переменная может быть доступна из двух разных потоков и множество блокировок, которые захвачены, непересекаются, то генерируется предупреждение о возможном возникновении гонки. Вторым шагом является определение множества захваченных блокировок.

\section{RELAY}

Метод основан на концепции относительного множества блокировок (англ. relative lockset). Эти множества позволяют описать изменения множеств захваченных и освобожденных блокировок относительно точки входа в функцию. Относительные множества блокировок позволяют обобщить поведение функции независимо от контекста её вызова.

При анализе функции обрабатываются изолированно друг от друга снизу вверх в графе вызовов функций. Анализ каждой функции выполняется в 3 этапа:
\begin{itemize}
\item символьное исполнение,
\item анализ относительных множеств блокировок,
\item анализ защищенности доступа.
\end{itemize}

Основа для анализа относительных множеств блокировок и для анализа защищенности доступа закладывается на этапе символьного исполнения программы. Основной задачей этого этапа являтся выражение значений переменных функции через её формальные параметры и глобальные переменные программы. В ходе анализа для каждой инструкции в программе строится отображение вида $\sum: O->V$, где $O$ и $V$ множества левых и правых частей операторов присваивания, которые используются при символьном исполнении, соответственно. (TODO: переделай определения O и V, переосмысли их) Обозначим через $os \in 2^{o}$ - множество левых частей оператора присваивания, через $x \in X$ - формальные парметры функции и глобальные переменные программы и через $p \in P$ - узлы представителей классов эквивалентности, полученные с использованием алгоритма Стинсгарда для анализа указателей. Тогда левая часть оператора присваивания $o \in O$ может иметь вид - $x | x.f | p.f | (∗o).f$, а правая $v \in V$ - $⊥ | T | i | init(o) | must(o) | may(os)$, где $⊥$ означает "значение еще не было присвоено", $T$ означает "любое возможное значение", $i$ означает целочисленную константу, $init(o)$ представляет присваемое значение, $must(o)$ представляет значение, которое должно указывать на левую часть оператора присваивания $o$, $may(os)$ представляет значение, которое может указывать на любую левую часть операторов присваивания из $os$.

При символьном исполнении функции также следует учитывать влияние, которое могут оказывать другие потоки на состояние переменных. Для определения областей памяти, которые могут быть доступны вне потока, используется алгоритм Стинсгарда. Эти области памяти помечаются символом $T$, означающим, они могут иметь "любое возможное значение" после каждого вызова функции.

После завершения этапа символьного исполнения, начинается анализ относительных множеств блокировок. \textbf{Относительным множеством блокировок} называется пара $(L_{+}, L_{-})$, состоящая из $L_{+} \in O$ - множества безусловно (обязательно) захватываемых при выполнении блокировок и $L_{-} \in O$ - множества блокировок, которые могут быть освобождены при выполнении. Обозначим множество всех относительных множеств блокировок как $L = 2^{O} x 2^{O}$. Анализ множества блокировок - это анализ потока данных на решётке $(L, \bot, \top, \sqsubseteq, \sqcup, \sqcap)$ (посмотри определение решетки  и алгебры), где
\begin{itemize}
\item $\bot = (O, \emptyset)$, $\top = (\emptyset, O)$
\item $(L_{+}, L_{-}) \sqsubseteq (L_{+}', L_{-}') \Longleftrightarrow L_{+}' \subseteq L_{+} \wedge L_{-} \subseteq L_{-}'$
\item $(L_{+}, L_{-}) \sqcup (L_{+}', L_{-}') = (L_{+} \cap L_{+}', L_{-} \cup L_{-}')$
\item $(L_{+}, L_{-}) \sqcap (L_{+}', L_{-}') = (L_{+} \cup L_{+}', L_{-} \cap L_{-}')$
\end{itemize}

Анализ выполняется снизу вверх в графа вызовов функций. После того, как функция $f$ проанализирована, её влияние на множества блокировок сохраняется как обобщение $LockSummary(f) \in L$, представляющее относительное множество блокировок в конце функции. Для упрощения предполагается, что функция может принимать только один параметр. Операции захвата и освобождения блокировки моделируются как выховы функции, инструкции, которые изменяют состояние множеств блокировок - как вызов функции $e(a)$. В частности, обобщение функции $lock(l)$ моделируется относительным множеством блокировок $(\{l\}, \{\}))$, а фукнции $unlock(l)$ - $(\{\}, \{l\})$. Учитывая вызов функции e(a), для каждой функции $f$, которую может представлять $e$, функция потока сначала получает обобщение $LockSummary(f)$и затем, используя функцию $rebind$ ($rebind(q, f, e) = q[formal(f ) → eval(e)]$(, заменяет все вхождения формадльных аргументов функции $f$ на те, которые были переданы фактически. Результирующее обобщение представляет изменения множества блокировок, которое происходит с момента начала выполнения $f$ и до выхода из неё. Чтобы найти относительное множество блокировок после вызова $f$ (в каком-либо месте программы) к нему применяются изменения,задаваемые обобщением $f$.

После окончания анализа множества блокировок для функции выполняется анализ защищенности доступа (англ. guarded access analysis). \textbf{Под защищенным доступом} понимается тройка $a = (o, L, k)$, где $o \in O$ - левые части операторов присваивания (lvalue подумай как это обозвать), к которым производится доступ, $L \in \mathbf{L}$ - относительное множество блокировок, в мечте доступа, $k \in K = {Read, Write}$ - вид доступа (чтение или запись). Построение обобщения защищенных доступов для функции аналогично построению обобщения для относительных множеств блокировок за исключением того, что вычисление множества доступов не нужно делать потоко-чувствительным, и обходить присваивания можно в любом порядке.
