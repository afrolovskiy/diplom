\chapter{Статический анализ гонок}
\label{cha:static-methods}

При статическом анализе для поиска гонок используются следующие подходы:
\begin{itemize}
\item аннотирование кода,
\item анализ потока выполнения программы.
\end{itemize}

\textbf{Аннотирование кода} выполняется за счёт добавления специальных конструкций, содержащих информацию об объектах взаимоисключения, обеспечивающих защиту доступа к переменным, вызовам функций в исходный код программы. В листинге~\ref{lst:annotation_example1} и листинге~\ref{lst:annotation_example2} представлены примеры разных способов аннотирования кода для контроля захвата блокировок при доступе к переменным или функциям. Недостатком данного метода является необходимость добавления большого числа аннотаций, что влечет за собой увеличение объема кода, а, следовательно, и ухудшение читаемости кода, а также возможность допущения ошибок при самом аннотировании. Достоинством данного метода является гарантированная проверка захвата необходимых объектов взаимоисключения, указанных в аннотации, за исключением особых случаев, примеры которых показаны в листинге~\ref{lst:annotation_example2}.

\lstinputlisting[language=Java,caption=Пример №1. Аннотирование кода (\Code{annotation1.java}),label=lst:annotation_example1]{inc/src/annotation1.java}

\lstinputlisting[language=C,caption=Пример №2. Аннотирование кода (\Code{annotation2.cpp}),label=lst:annotation_example2]{inc/src/annotation2.cpp}

\lstinputlisting[language=C,caption=Пример №3. Аннотирование кода (\Code{annotation3.cpp}),label=lst:annotation_example3]{inc/src/annotation3.cpp}

\textbf{Анализ потока выполнения программы} бла-бла-бла.

Основная идея статического поиска гонок заключается в том, чтобы удостовериться, что для каждой общей области памяти существует по крайней мере одна блокировка, которая берётся во всех потоках при доступе к этой области. Тогда в случае, когда один поток удерживает блокировку, обеспечивается взаимно исключающий доступ к данным, что позволяет избежать гонок. Для того, чтобы определить, существует ли общая блокировка, можно вычислить набор блокировок, которые удерживаются в каждой точке программы, при этом должны отслеживаться только те блокировки, которые захватываются на всех путях, проходящих через эту точку. Вычислив множества всегда удерживаемых блокировок для каждой точки программы, достаточно просто проверить пересечение этих множеств в тех точках, где происходит доступ к исследуемой области памяти. Если пересечение не пусто, то можно сделать вывод о том, что гонки при доступе к данной области памяти отсутствуют, в противном случае существует потенциальная возможность возникновения гонок.

Чтобы применить эти базовые идеи к анализу реальных программ на C, нужно решить следующие задачи. Прежде всего, нужно определить области памяти, к которым производится доступ, что является нетривиальной задачей. Даже без динамического выделения памяти нужно провести анализ указателей. Например, если два различных указателя, p и q, указывают на одну и ту же область памяти, то, например, доступ к полям структуры p->data и q->data может привести к гонкам. Операции захвата и освобождения блокировок на языке C лексически не ограничены, поэтому информацию об указателях необходимо отслеживать контексто-чувствительно. Рассмотрим пример, представленный в листинге~\ref{lst:example1} 

\lstinputlisting[language=C,caption=Пример(\Code{example1.c}),label=lst:example1]{inc/src/example1.c}

Выполнение функции munge зависит от контекста, в котором происходит её вызов. В функции поседовательно выполняется захват блокировки, увеличение значения разделяемой переменной и освобожение блокировки. Переменная и блокировка передаются в фукнцию через указатели. Результат выполнения функции зависит от контекста, в котором она вызывается. К сожалению, получение контекстно-чувствительной информации об указателях является вычислительно дорогостоящим. Анализ каждого набора значений параметров вызываемой функции на основе полного перебора приводит к комбинаторному взрыву.

Существует три различных метода статического анализа, позволяющие решить эти проблемы:
\begin{itemize}
\item Locksmith,
\item CoBE,
\item RELAY.
\end{itemize}

Следует тометим, что контекстная-зависимость является не единственной проблемой, возникающей при статическом поиске гонок в программах на языке C. Во-первых, мьютексы являются не единственным способом обеспечения монопольного доступа к данным, cуществуют иные операции блокировки, например, семафоры. Во-вторых, возникают проблемы при анализе указателей, связанные с динамическим выделением памяти...

бла-бла-бла

Рассмотрим далее каждый из указанных методов подробнее.

\section{Locksmith}
Locksmith

\section{CoBE}
CoBE

\section{RELAY}

Метод основан на концепции относительного множества блокировок (англ. relative lockset). Эти множества позволяют описать изменения множеств захваченных и освобожденных блокировок относительно точки входа в функцию. Относительные множества блокировок позволяют обобщить поведение функции независимо от контекста её вызова.

При анализе функции обрабатываются изолированно друг от друга снизу вверх в графе вызовов функций. Анализ каждой функции выполняется в 3 этапа:
\begin{itemize}
\item символьное исполнение,
\item анализ относительных множеств блокировок,
\item анализ защищенности доступа.
\end{itemize}

Основа для анализа относительных множеств блокировок и для анализа защищенности доступа закладывается на этапе символьного исполнения программы. Основной задачей этого этапа являтся выражение значений переменных функции через её формальные параметры и глобальные переменные программы. В ходе анализа для каждой инструкции в программе строится отображение вида $\sum: O->V$, где $O$ и $V$ множества левых и правых частей операторов присваивания, которые используются при символьном исполнении, соответственно. (TODO: переделай определения O и V, переосмысли их) Обозначим через $os \in 2^{o}$ - множество левых частей оператора присваивания, через $x \in X$ - формальные парметры функции и глобальные переменные программы и через $p \in P$ - узлы представителей классов эквивалентности, полученные с использованием алгоритма Стинсгарда для анализа указателей. Тогда левая часть оператора присваивания $o \in O$ может иметь вид - $x | x.f | p.f | (∗o).f$, а правая $v \in V$ - $⊥ | T | i | init(o) | must(o) | may(os)$, где $⊥$ означает "значение еще не было присвоено", $T$ означает "любое возможное значение", $i$ означает целочисленную константу, $init(o)$ представляет присваемое значение, $must(o)$ представляет значение, которое должно указывать на левую часть оператора присваивания $o$, $may(os)$ представляет значение, которое может указывать на любую левую часть операторов присваивания из $os$.

При символьном исполнении функции также следует учитывать влияние, которое могут оказывать другие потоки на состояние переменных. Для определения областей памяти, которые могут быть доступны вне потока, используется алгоритм Стинсгарда. Эти области памяти помечаются символом $T$, означающим, они могут иметь "любое возможное значение" после каждого вызова функции.

После завершения этапа символьного исполнения, начинается анализ относительных множеств блокировок. \textbf{Относительным множеством блокировок} называется пара $(L_{+}, L_{-})$, состоящая из $L_{+} \in O$ - множества безусловно (обязательно) захватываемых при выполнении блокировок и $L_{-} \in O$ - множества блокировок, которые могут быть освобождены при выполнении. Обозначим множество всех относительных множеств блокировок как $L = 2^{O} x 2^{O}$. Анализ множества блокировок - это анализ потока данных на решётке $(L, \bot, \top, \sqsubseteq, \sqcup, \sqcap)$ (посмотри определение решетки  и алгебры), где
\begin{itemize}
\item $\bot = (O, \emptyset)$, $\top = (\emptyset, O)$
\item $(L_{+}, L_{-}) \sqsubseteq (L_{+}', L_{-}') \Longleftrightarrow L_{+}' \subseteq L_{+} \wedge L_{-} \subseteq L_{-}'$
\item $(L_{+}, L_{-}) \sqcup (L_{+}', L_{-}') = (L_{+} \cap L_{+}', L_{-} \cup L_{-}')$
\item $(L_{+}, L_{-}) \sqcap (L_{+}', L_{-}') = (L_{+} \cup L_{+}', L_{-} \cap L_{-}')$
\end{itemize}

