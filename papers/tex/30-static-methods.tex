\chapter{Статический анализ гонок}
\label{cha:static-methods}

При статическом анализе для поиска гонок используются следующие подходы:
\begin{itemize}
\item аннотирование кода,
\item анализ потока выполнения программы.
\end{itemize}

\textbf{Аннотирование кода} выполняется за счёт добавления специальных конструкций, содержащих информацию об объектах взаимоисключения, обеспечивающих защиту доступа к переменным, вызовам функций в исходный код программы. В листинге~\ref{lst:annotation_example1} и листинге~\ref{lst:annotation_example2} представлены примеры разных способов аннотирования кода для контроля захвата блокировок при доступе к переменным или функциям. Недостатком данного метода является необходимость добавления большого числа аннотаций, что влечет за собой увеличение объема кода, а, следовательно, и ухудшение читаемости кода, а также возможность допущения ошибок при самом аннотировании. Достоинством данного метода является гарантированная проверка захвата необходимых объектов взаимоисключения, указанных в аннотации, за исключением особых случаев, примеры которых показаны в листинге~\ref{lst:annotation_example2}.

\lstinputlisting[language=Java,caption=Пример №1. Аннотирование кода (\Code{annotation1.java}),label=lst:annotation_example1]{inc/src/annotation1.java}

\lstinputlisting[language=C,caption=Пример №2. Аннотирование кода (\Code{annotation2.cpp}),label=lst:annotation_example2]{inc/src/annotation2.cpp}

\lstinputlisting[language=C,caption=Пример №3. Аннотирование кода (\Code{annotation3.cpp}),label=lst:annotation_example3]{inc/src/annotation3.cpp}

\textbf{Анализ потока выполнения программы} бла-бла-бла.

Основная идея статического поиска гонок заключается в том, чтобы удостовериться, что для каждой общей области памяти существует по крайней мере одна блокировка, которая берётся во всех потоках при доступе к этой области. Тогда в случае, когда один поток удерживает блокировку, обеспечивается взаимно исключающий доступ к данным, что позволяет избежать гонок. Для того, чтобы определить, существует ли общая блокировка, можно вычислить набор блокировок, которые удерживаются в каждой точке программы, при этом должны отслеживаться только те блокировки, которые захватываются на всех путях, проходящих через эту точку. Вычислив множества всегда удерживаемых блокировок для каждой точки программы, достаточно просто проверить пересечение этих множеств в тех точках, где происходит доступ к исследуемой области памяти. Если пересечение не пусто, то можно сделать вывод о том, что гонки при доступе к данной области памяти отсутствуют, в противном случае существует потенциальная возможность возникновения гонок.

Чтобы применить эти базовые идеи к анализу реальных программ на C, нужно решить следующие задачи. Прежде всего, нужно определить области памяти, к которым производится доступ, что является нетривиальной задачей. Даже без динамического выделения памяти нужно провести анализ указателей. Например, если два различных указателя, p и q, указывают на одну и ту же область памяти, то, например, доступ к полям структуры p->data и q->data может привести к гонкам. Операции захвата и освобождения блокировок на языке C лексически не ограничены, поэтому информацию об указателях необходимо отслеживать контексто-чувствительно. Рассмотрим пример, представленный в листинге~\ref{lst:example1} 

\lstinputlisting[language=C,caption=Пример(\Code{example1.c}),label=lst:example1]{inc/src/example1.c}

Выполнение функции munge зависит от контекста, в котором происходит её вызов. В функции поседовательно выполняется захват блокировки, увеличение значения разделяемой переменной и освобожение блокировки. Переменная и блокировка передаются в фукнцию через указатели. Результат выполнения функции зависит от контекста, в котором она вызывается. К сожалению, получение контекстно-чувствительной информации об указателях является вычислительно дорогостоящим. Анализ каждого набора значений параметров вызываемой функции на основе полного перебора приводит к комбинаторному взрыву.

Существует три различных метода статического анализа, позволяющие решить эти проблемы:
\begin{itemize}
\item Locksmith,
\item CoBE,
\item RELAY.
\end{itemize}

Следует тометим, что контекстная-зависимость является не единственной проблемой, возникающей при статическом поиске гонок в программах на языке C. Во-первых, мьютексы являются не единственным способом обеспечения монопольного доступа к данным, cуществуют иные операции блокировки, например, семафоры. Во-вторых, возникают проблемы при анализе указателей, связанные с динамическим выделением памяти...

бла-бла-бла

Рассмотрим далее каждый из указанных методов подробнее.

\section{Locksmith}
Locksmith

\section{CoBE}
CoBE

\section{RELAY}

Метод основан на концепции относительного множества блокировок (англ.relative lockset). Эти множества позволяют описать изменения множеств блокировок относительно точки входа в функцию. В них содержится выраженная через входные параметры функции информация об областях памяти, к которым производится доступ. Относительные множества блокировок позволяют обобщить поведение функции независимо от контекста её вызова.

\textbf{Относительным множеством блокировок} $L$ называется пара вида $(L_{+}, L_{-})$, состоящая из $L_{+}$ - множества безусловно захватываемых блокировок при каждом выполнении и $L_{-}$ - множества блокировок, которые могут быть освобождены при выполнении.

Функции при анализе обрабатываются изолированно друг от друга снизу вверх в графе вызово функций. Для каждой функции выполняется 3 вида анализа:
\begin{itemize}
\item символьное исполнение (англ. symbolic execution),
\item анализ относительных множеств блокировок,
\item анализ защищенности доступа.
\end{itemize}
