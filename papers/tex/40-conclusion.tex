\Conclusion

Кнтекстная зависимость является не единственной проблемой, возникающей при статическом поиске гонок в программах на языке C. Во-первых, отметим, что мьютексы являются не единственным способом обеспечения монопольного доступа к данным, cуществуют иные операции блокировки, например, семафоры. Несмотря на то, что поведение семафоров может быть, например, проимулировано с использованием мьютексов, это может привести к возникновению новых ложных срабатываний. Во-вторых, возникают проблемы при анализе указателей, связанные с динамическим выделением памяти. В-третьих, разрешение проблем, связанных с условными блокировками, также явлется весьма нетривиальной задачей анализа.

Самым надёжным способом обеспечения отсутсвия гонок является исполнение только одного потока. Даже в многопоточной программе поток может не всегда выполняться параллельно с другими потоками. Существует много механизмов обеспечения синхронизации без блокировок (англ. lock-free). Например, предположим, что есть главный поток и $k$ рабочих потоков (англ. workers). Главный поток содержит массив $A$ с $k$ элементами (по одному для каждого из потоков) такой, что $A[i]$ влияет на $i$ поток. Более того, предположим, что основной поток инициализирует этот массив перед порождением рабочих потоков (англ. worker threads) и обрабатывает этот массив после завершения всех потоков. Хотя нет блокировок, программа не содержит гонок, т.к. главный поток осуществляет доступ к массиву только тогда, когда рабочие потоки не имеют, и рабочие потоки следуют этому соглашению, что обеспечивает монопольный доступ.

Обычно выделяют временный фазы работы программы такие, как инициализация, обработка и постобработка. Анализатор должен поэтому определять не только какие потоки могут работать параллельно, но и факт того, что два рассматриваемых доступа к памяти могут действительно конфликтовать, принимая во внимание к каким данным и в какое время производится доступ. Традиционный подход заключается в попытке частично упорядочить инструкции, когда очевидно, что что-то должно произойти прежде, чем другие операции. Гонка может произойти при одновременном доступе только, если нет ограничений последовательности выполнения. Это используется многими динамическим анализаторами, например, Intel Checker.
