Цель и задачи

Цель: разработать метод статического поиска гонок в программах на языке Си

Задачи:
- Выполнить анализ методов поиска гонок в программах
- Разработать метод статического поиска гонок при доступе к разделяемой памяти
- Разработать алгоритм статического поиска гонок на основе предложенного метода
- Разработать ПО, реализующее предлагаемый метод
- Провести исследование разработанного метода

Понятие гонки

Интенсивное развитие информационных технологий и расширение сферы их применения
привело к значительному увеличению сложности используемого программного
обеспечения, а также росту количества и критичности выполняемых им функций. С
увеличением сложности возрастает количество ошибок. Ущерб от них несет
существенные последствия. Одними из наиболее опасных являются ошибки, связанные
с гонками при работе с данными. Они носят стохастический характер, что
обуславливает сложность их выявления и исправления.

Состояние гонки - ситуация, когда несколько потоков одновременно совершают
доступ к общей области памяти, и хотя бы один из них выполняет операцию записи
в неё.

На представленном примере видно, что доступ к переменной count является
незащищенным, т.к. потенциально возможно возникновение гонки при доступе к ней.
Например, возможна следующая ситуация 1-ый и 2-ой потоки одновременно прочитали
текущее значение этой переменной, увеличили его на единицу и записали результат
обратно в эту же переменную. В этом случае значение переменной увеличится не на
2, как ожидается, а на 1.

Методы поиска гонок

Формальная верификация основана на установлении соответствия между программой
и требованиями к программе, описывающими цель разработки. Основными методами
формальной верификации являются метод проверки моделей и дедуктивный анализ.

Основная идея дедуктивного анализа состоит в том, чтобы последовательными
преобразованиями привести программу в формулу логики (требования к программе
либо изначально формулируются на языке логики, либо переводятся с какого-либо
языка на язык логики). После этого доказательство корректности программы
сводится к доказательству эквивалентности двух формул, что осуществляется с
помощью методов, разработанных в логике. Данный метод хорошо разработан для
последовательных программ, для параллельных - процесс сильно усложняется.

Метод проверки моделей заключается в том, что желаемые свойства поведения
реагирующей системы проверяются на заданной системе (модели) путём
исчерпывающего перебора всех состояний, достижимых системой, и всех поведений
(путей), проходящих через эти состояния. Основным недостатком данного метода
является комбинаторный взрыв в пространстве состояний, возникающий в случае,
когда исследуемая система состоит из многих компонент, переходы в которых
выполняются параллельно.

Динамический анализ основан на изучении потока событий, генерируемых программой
во время выполнения. Недостатком данного метода является то, что состояние
гонки может быть зафиксировано, только если оно возникло в проверяемом варианте
исполнения программы, а, значит, нет гарантии, что оно не может возникнуть в
каком-то ином варианте. Другим существенным недостатком является то, что
большинство средств динамического анализа зависит от оснащения приложения
средствами мониторинга, что может менять поведение исполняющей среды.

Статический анализ основан на анализе исходного кода программы (или бинарного
кода) без его исполнения. Достоинством данного метода является теоретическая
возможность анализа всех возможных путей выполнения программы. Недостатком
является наличие ложных срабатываний (ложных предупреждений), то есть
обнаружение ситуаций гонок в тех местах программы, где их нет, что усложняет
анализ и выявление тех результатов, которые соответствуют действительным
ситуациям гонок. Примером такой ситуации является инициализация переменных
в момент, когда программа выполняется в рамках одного процесса или потока.

Основная идея статического поиска гонок заключается в том, чтобы удостовериться,
что для каждой общей области памяти существует по крайней мере одна блокировка,
которая берётся (захватывается) во всех потоках при доступе к этой области
памяти. Тогда в случае, когда один поток удерживает блокировку, обеспечивается
взаимноисключающий (монопольный) доступ к данным, что позволяет избежать гонок.
Для того, чтобы определить, существует ли общая блокировка, можно вычислить набор
блокировок, которые удерживаются в каждой точке программы, при этом должны
отслеживаться только те блокировки, которые захватываются на всех путях,
проходящих через эту точку. Вычислив множества всегда удерживаемых блокировок
для каждой точки программы, достаточно просто проверить пересечение этих множеств
в тех точках, где происходит доступ к исследуемой области памяти. Если
пересечение не пусто, то можно сделать вывод о том, что гонки при доступе к
данной области памяти отсутствуют, в противном случае существует потенциальная
возможность возникновения гонок.

Аннотирование кода выполняется за счёт добавления в исходный код программы
специальных конструкций, содержащих информацию об объектах взаимоисключения и
обеспечивающих защиту доступа к переменным и вызовам функций . Недостатком
данного метода является необходимость добавления большого числа аннотаций,
что влечет за собой увеличение объема кода, а, следовательно, и ухудшение
читаемости кода, а также возможность допущения ошибок при самом аннотировании.
Достоинством данного метода является гарантированная проверка захвата\
необходимых объектов взаимоисключения, указанных в аннотации, за исключением
некоторых особых случаев (например, случаи, когда ведется работа с массивом
блокировок, блокировки захватываются не безусловно, а только при выполнении
каких-то условий и т.п.).

Анализ потока выполнения осуществляется на основе всевозможных путей выполнения
программы. Графически поток выполнения может быть представлен в виде графа
потока управления, который представляет из себя направленный граф, отражающий
переходы между так называемыми базовыми блоками программы. Базовым блоком
является линейный участок кода, не содержащий ветвлений, за исключением быть
может первой и последней инструкций.



Нахождение перекрестных ссылок

PT[v] – множество областей памяти, на которые ссылается переменная  v.
